[{"title":"Shell Expansion","date":"2019-08-21T09:55:57.000Z","path":"2019/08/21/bash_expansion/","excerpt":"说明在将命令行拆分为 tokenS 后，将在命令行上执行扩展。 七种 expansion按照 expansion 的顺序排序如下： Brace Expansion Tilde Expansion Parameter and Variable Expansion Arithmetic Expansion Command Substitution Word Splitting Filename Expansion","tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}]},{"title":"阅读列表","date":"2019-06-29T06:56:10.000Z","path":"2019/06/29/read/","excerpt":"","tags":[{"name":"已阅","slug":"已阅","permalink":"http://yoursite.com/tags/已阅/"}]},{"title":"怎么写 Commit Message？","date":"2019-06-12T12:21:44.000Z","path":"2019/06/12/commit_message/","excerpt":"Commit Message 是告诉其他人你在提交中完成了哪些操作的最简单方法。通过阅读 Commit Message，您应该能够在不查看提交的情况下说出更改的范围和更改背后的一般思想。 Commit Message一条好的 Commit Message 应该包含以下部分。 标题这是一个单行摘要，它应该帮助其他人快速浏览列表并找到他们想要的 commit。 这一行不应该超过 80 个字符，因为这是 Commit Message 中惟一保证在所有工具中都能看到的部分，而 Commit Message 的其余部分很可能是隐藏的。例如，“git log”、“git blame” 和 BitBucket commit 视图只显示这一行。","tags":[{"name":"技术名词","slug":"技术名词","permalink":"http://yoursite.com/tags/技术名词/"}]},{"title":"Golang slice 之 append 时原数组发生变化","date":"2019-05-28T11:22:34.000Z","path":"2019/05/28/go_slice/","excerpt":"背景使用 append 可以在 slice 之后追加元素，例如 123a := []int&#123;1,2,3&#125;result := append(a,4)fmt.Println(result) // output: [1 2 3 4] 问题在于，进行这种操作时，原来的 slice（即 a）所基于的数组值会不会发生变化？在 Golang 中，如果有多个 slice 基于同一个数组，则这些 slice 的数据是共享的（而不是每个 slice 复制一份，复制的是指针）。也就说，如果改变了数组的内容，则基于它的所有 slice 的值都会发生变化。这段代码中 a 的值没有发生变化，是有原因的。","tags":[{"name":"Go","slug":"Go","permalink":"http://yoursite.com/tags/Go/"}]},{"title":"gRPC 详解","date":"2019-04-30T10:21:44.000Z","path":"2019/04/30/grpc/","excerpt":"什么是 gRPC？指南这篇文档向你介绍了什么是 gRPC 和 protocol buffers。gRPC 可以使用 protocol buffers 作为其接口定义语言（IDL）和底层消息交换格式。如果你是 gRPC 和 protocol buffers 新手，那么读这篇文档可以帮助到你，如果你只是想看看 gRPC 是怎么运作的，直接看快速开始。","tags":[{"name":"技术名词","slug":"技术名词","permalink":"http://yoursite.com/tags/技术名词/"}]},{"title":"什么是闭包 ？","date":"2019-04-24T10:21:44.000Z","path":"2019/04/24/closure/","excerpt":"闭包（closure）是 Javascript 语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。 变量作用域要理解闭包，首先要理解 Javascript 特殊的变量作用域。 变量的作用域无非就是两种：全局变量和局部变量。 Javascript 语言的特殊之处，就在于函数内部可以直接读取全局变量。 12345var n = 999;function f1()&#123; alert(n);&#125;f1(); // 999","tags":[{"name":"Go","slug":"Go","permalink":"http://yoursite.com/tags/Go/"},{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"技术名词","slug":"技术名词","permalink":"http://yoursite.com/tags/技术名词/"}]},{"title":"Linux 中硬连接（hard link）与软连接（symbolic link）的区别","date":"2019-04-22T04:17:10.000Z","path":"2019/04/22/soft_hard_link/","excerpt":"首先要简单了解一下 Linux 的 Ext 文件系统，此处传送门。 Linux Ext文件系统Linux 的 Ext 文件系统是如何与磁盘内存产生对应的呢？我们知道，在使用磁盘内存之前，需要为磁盘分区，然后为所分区域格式化出一个统一的文件系统（也有例外，如LVM与磁盘阵列技术）。那么，在这样一个统一的文件系统中，根据数据的不同，就可以将内存分为以下 3 种类型： inode：记录文件的属性，一个文件占用一个 inode，同时记录此文件的数据所在的 block 号码。当用户搜索或者访问一个文件时，UNIX 系统通过 inode 表查找正确的 inode 编号。在找到 inode 编号之后，相关的命令才可以访问该 inode，并对其进行适当的更改。 例如使用vi来编辑一个文件。当您键入vi 时，在 inode 表中找到 inode 编号之后，才允许您打开该inode。在 vi 的编辑会话期间，更改了该inode中的某些属性，当您完成操作并键入 :wq 时，将关闭并释放该 inode。通过这种方式，如果两个用户试图对同一个文件进行编辑， inode 已经在第一个编辑会话期间分配给了另一个用户 ID (UID)，因此第二个编辑任务就必须等待，直到该 inode 释放为止。","tags":[{"name":"技术名词","slug":"技术名词","permalink":"http://yoursite.com/tags/技术名词/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"MAC 如何配置 PATH 环境变量？","date":"2019-04-19T09:28:10.000Z","path":"2019/04/19/mac_path/","excerpt":"之前在配置 MAC 环境变量的时候，总是云里雾里的不知道要怎么配置，都是从网上找配置方案，然后成功了完事大吉，不成功就换一种配置方案，所以并不知道为什么要这么配置，今天就来整理一下 MAC 应该如何来配置环境变量。 Mac osx 下环境变量的加载顺序MAC 默认的终端是 bash。 123456/etc/profile # 系统级，系统启动加载/etc/paths # 系统级，系统启动加载~/.bash_profile # 用户级~/.bash_login # 用户级~/.profile # 用户级~/.bashrc # 用户级","tags":[{"name":"PATH","slug":"PATH","permalink":"http://yoursite.com/tags/PATH/"},{"name":"MAC","slug":"MAC","permalink":"http://yoursite.com/tags/MAC/"}]},{"title":"加锁 Mutex 和 Channel 性能对比","date":"2019-04-19T06:38:40.000Z","path":"2019/04/19/mutex_or_channel/","excerpt":"性能对比首先在一个目录下新建两个文件： main.go 1234567891011121314151617// main.gopackage mainimport \"sync\"var mutex = sync.Mutex&#123;&#125;var ch = make(chan bool, 1)func UseMutex() &#123; mutex.Lock() mutex.Unlock()&#125;func UseChan() &#123; ch &lt;- true &lt;-ch&#125;","tags":[{"name":"Go","slug":"Go","permalink":"http://yoursite.com/tags/Go/"}]},{"title":"什么是 logrotate ？","date":"2019-04-18T10:28:44.000Z","path":"2019/04/18/logrotate/","excerpt":"什么是 logrotatelogrotate 旨在简化生成大量日志文件的系统的管理。它允许自动循环、压缩、删除和邮寄日志文件。每个日志文件可以按每天、每周、每月的粒度来处理，也可以在其增长过大时处理。 通常来说，logrotate 作为日常 cron 作业运行。它一天内修改日志的次数不会超过一次，除非该日志的标准基于日志的大小，并且 logrotate 每天运行一次以上，或者使用 -f 或 -force 的选项。 在命令行上可以给出任意数量的配置文件。稍后的配置文件可能会覆盖前面文件中给出的选项，因此列出 logrotate 配置文件的顺序很重要。通常，应该使用一个配置文件，其中包含需要的任何其他配置文件。有关如何使用 include 指令来完成此任务的更多信息，请参见 man page。如果在命令行上给出一个目录，则该目录中的每个文件都是配置文件。 如果没有给出命令行参数，logrotate 将打印版本和版权信息，以及一个简短的使用总结。如果在循环日志时发生任何错误，logrotate 将以非零状态退出。","tags":[{"name":"技术名词","slug":"技术名词","permalink":"http://yoursite.com/tags/技术名词/"},{"name":"运维","slug":"运维","permalink":"http://yoursite.com/tags/运维/"},{"name":"Log","slug":"Log","permalink":"http://yoursite.com/tags/Log/"}]},{"title":"什么是 RSS ？","date":"2019-04-14T10:28:44.000Z","path":"2019/04/14/rss/","excerpt":"什么是 RSS ？\b在解释 RSS 是什么之前，让我先来打一个比方。 读大学的时候，我有个习惯，就是每天要去看食堂后面的海报栏。在那里，会贴出各种各样最新的消息，比如哪个系要开讲座了、星期二晚上的电影放什么、二手货转让等等。只要看一下海报栏，就会对学校的各种活动心中有数。 如果没有海报栏的话，要想知道这些消息就会很麻烦。讲座消息会贴在各个系自己的公告栏里，电影排片表是贴在电影院里的，二手货消息则会贴在各幢宿舍的楼道里。我所在的大学有 20 几个系，一万多人，要想知道所有这些消息的话，即使是可能的话，也会相当的麻烦。 从这个例子出发，让我们来考虑一下互联网。","tags":[{"name":"技术名词","slug":"技术名词","permalink":"http://yoursite.com/tags/技术名词/"}]}]